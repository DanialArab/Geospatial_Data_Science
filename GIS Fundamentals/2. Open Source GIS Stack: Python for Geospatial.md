## Open Source GIS Stack: Python for Geospatial

The focus of this part is on the **FOSS4G** (Free and Open Source Software for Geospatial) stack. The content has 3 parts:

+ Loading software and data
+ Python packages
+  Geospatial additions to Python

# Table of Content


1. [Software installation](#1)
    1. [QGIS (Quantum GIS)](#2)
    2. [PostgreSQL](#3)
2. [Spatialite](#4)
3. [Usefull Python packages](#5)
    1. [psycopg2](#6)
    2. [pypiwin32](#7)
    3. [Python Geocoding packages](#8)
        1. [censusgeocode](#9)
        2. [geocoder](#10)
        
4. [Python with Desktop ArcGIS and QGIS ](#11)
5. [Hands-on exercises](#12)
6. [Reference](#13)

<a name="1"></a>
### Software installation:

<a name="2"></a>
+ **QGIS (Quantum GIS)** is a free and open-source GIS software that allows users to view, edit, and analyze geospatial data. It is designed to provide a user-friendly interface for creating, visualizing, and publishing geospatial information. QGIS can be used for a variety of tasks, such as creating and editing maps, analyzing and manipulating data, and publishing maps and data on the web. QGIS is compatible with a wide range of data formats, including shapefiles, GeoTIFF, KML, and PostGIS. It also supports a range of geospatial operations, such as geocoding, geoprocessing, and spatial analysis. QGIS is a popular choice among researchers, GIS professionals, and other users who need to work with geospatial data. 

link to download: https://www.qgis.org/en/site/forusers/download.html
<a name="3"></a>
+ **PostgreSQL**

As  a database management system (DBMS), we use PostgreSQL. 

PostgreSQL and MySQL have many similarities, but they also have some differences in terms of features, performance, and the way they handle certain tasks. For example, PostgreSQL has more advanced features for handling complex data types, concurrency control, and transactions, while MySQL is known for its performance and ease of use.

link to download: https://www.enterprisedb.com/downloads/postgres-postgresql-downloads

**Note on pg_qgs.qgz file (QGIS Project file)**:

The QGIS Project file named "pg_qgs.qgz"which was discussed in the course was missing in the course material. And so I created it through connecting to my PostgreSQL:

To create a QGIS project file that connects to your PostgreSQL database, you can follow these steps:

+ Open QGIS and click on "New Project" to create a new project.

+ In the "Create a new project" window, give your project a name and choose a location to save it.

+ In the "Data Source Manager" window, click on "PostgreSQL" in the left-hand panel to add a new connection to your PostgreSQL database.

+ In the "Create a new PostGIS connection" window, enter the connection details for your PostgreSQL database, including the host, port, database name, and authentication credentials.

+ Once you have entered the connection details, click on "Test Connection" to make sure that the connection is successful. If the connection is successful, click on "OK" to save the connection.

+ In the "Data Source Manager" window, expand the "PostgreSQL" connection to see the list of available tables and views in your database.

+ To add a table or view to your QGIS project, simply drag and drop it from the "Data Source Manager" window into the QGIS canvas.

+ Once you have added all the layers you want to your project, you can save the project by clicking on "Project" in the top menu bar and selecting "Save" or "Save As".

To open the project in QGIS again, simply double-click on the project file (.qgs) or open QGIS and click on "Open Project" in the start menu.


### Useful functions in PostgreSQL's PostGIS extension

+ **ST_TRANSFORM**: is a spatial function in PostgreSQL's PostGIS extension, which is used to transform the spatial reference system (SRS) of a geometry or geography object. 

    SELECT ST_TRANSFORM(geom,4326) AS geom
    FROM firestations

+ **ST_DISTANCE**: is a function in the PostGIS extension for PostgreSQL that calculates the distance between two geometric objects in a specified spatial reference system (SRS).

### SQLITE

Some simple practice:

        import sqlite3
        import os

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        answer = conn.execute('SELECT parcelkey, asmt FROM parcels LIMIT 3')
        for row in answer:
            print (row)

So through the above query I can get the parcel keys and the corresponding assessment values for the first three records:

        ('50070005900000070030000000', 160000.0)
        ('50070005900000070020000000', 260000.0)
        ('50070005700000010020010000', 190000.0)

As another example: 

        import sqlite3
        import os 

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        answer = conn.execute(f"SELECT  propclass, AVG(asmt) AS sumasmt FROM parcels GROUP BY propclass ORDER BY sumasmt ")
        for row in answer: 
            print (f"The average assessment for the property class {row[0]} is $ {row[1]:.2f}")

Which gives me the average assessment for each property class:

        The average assessment for the property class Vacant is $ 68937.44
        The average assessment for the property class   is $ 116666.67
        The average assessment for the property class Forest is $ 125865.74
        The average assessment for the property class Residential is $ 221603.24
        The average assessment for the property class Agriculture is $ 405663.41
        The average assessment for the property class Recreation is $ 922301.08
        The average assessment for the property class Commercial is $ 963517.88
        The average assessment for the property class Public Services is $ 1509577.66
        The average assessment for the property class Industrial is $ 1747535.51
        The average assessment for the property class Community Srvcs is $ 18435283.21

<a name="4"></a>
### Spatialite

Spatialite is a spatial extension for SQLite, which is a lightweight, serverless, open-source database management system. Spatialite adds support for spatial data types, spatial indexing, and spatial functions to SQLite, making it a powerful tool for managing and analyzing spatial data. Just like Postgres has PostGSI, SQL Server has SQL Server Spatial, and Oracle has Oracle Spatial, SQLite has Spatialite. 

To activate the Spatial part of SQLite, I need to load extension. So I can execute Spatial functions like ST_Intersects:

        import sqlite3
        import os 

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        conn.enable_load_extension(True) 
        conn.execute('SELECT load_extension("mod_spatialite")')
        answer = conn.execute("""
                        SELECT propclass, SUM(asmt) AS sumasmt
                        FROM parcels, floodzones
                        WHERE ST_INTERSECTS(parcels.geometry, floodzones.geom) AND floodzones.zone ='A'
                        GROUP BY propclass
                        ORDER BY sumasmt
        """)
        for row in answer:
            print (f"Property class {row[0]} has sum of assessment of $ {row[1]}")

which gives me back:

        Property class Industrial has sum of assessment of $ 1379700.0
        Property class Recreation has sum of assessment of $ 1732300.0
        Property class Forest has sum of assessment of $ 10067200.0
        Property class Vacant has sum of assessment of $ 23111320.0
        Property class Commercial has sum of assessment of $ 47901100.0
        Property class Agriculture has sum of assessment of $ 60125100.0
        Property class Public Services has sum of assessment of $ 96326812.0
        Property class Residential has sum of assessment of $ 160711600.0
        Property class Community Srvcs has sum of assessment of $ 6988285900.0

Another example using one of the Spatial functions (ST_DISTANCE) of Spatialite to find the minimum distance of a parcel from the flood zone:

        import sqlite3
        import os 

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        conn.enable_load_extension(True) 
        conn.execute('SELECT load_extension("mod_spatialite")')
        pkey = input('Enter your parcel key: ')
        answer = conn.execute("""   SELECT MIN(ST_DISTANCE(parcels.geometry, floodzones.geom)) AS dist
                                    FROM parcels, floodzones 
                                    WHERE parcels.parcelkey =""" + '\'' + pkey + '\'')
        for row in answer:
            if row [0]== 0:
                print ('parcel intersects the flood zone')
            else:
                print (row[0])

this query return me back (with parcel key of 50308902300000010340000000:

        1626.3723158804592

<a name="5"></a>
## Usefull Python packages

        pip install psycopg2 --upgrade
        pip install geocoder --upgrade
        pip install pypiwin32 
        pip install censusgeocode
        pip install geocoder 

<a name="6"></a>
### psycopg2
Connecting to PostgresSQL and PostGIS using Python:

Before we connected to SQLite through conencting to a file, here we are actually connecting to a database instance, we achive this using psycopg2:

        import psycopg2
        import os 

        conn = psycopg2.connect(dbname= 'tompkins', host = 'localhost', user = 'postgres', password = 'postgres', port = 5432)
        cursor = conn.cursor()
        cursor.execute("""SELECT tcparcel.parcelkey, zone
                            FROM floodzones, tcparcel
                            WHERE ST_INTERSECTS(tcparcel.geom, floodzones.geom)
                            LIMIT 10""")
        result = cursor.fetchall()

        for j in result:
            print (f"Parcel {j[0]} intersects zone {j[1]}")
    
this query gives me back:

        Parcel 50070000200000020040000000 intersects zone AE
        Parcel 50308901800000020100000000 intersects zone AE
        Parcel 50070052500000060010000000 intersects zone AE
        Parcel 50308952500000060010000000 intersects zone AE
        Parcel 50308901800000050150000000 intersects zone AE
        Parcel 50308901800000050020000000 intersects zone AE
        Parcel 50308901800000050140000000 intersects zone AE
        Parcel 50308901800000050050000000 intersects zone AE
        Parcel 50308901800000050090000000 intersects zone AE
        Parcel 50308901800000050120000000 intersects zone AE

<a name="7"></a>
## pypiwin32
### Making Python talk to Microsoft Excel

pypiwin32 is the package that lets us conenct to excel.

We already made python talk to PostgreSQL and through making it talking to Excel, three of them can talk to each other, which would be a great conversation:)!

Through this I can use all the Excel functionalities like:

        import win32com.client as wc

        excel = wc.Dispatch("Excel.Application")
        mylist = [10, 20, 30, 40, 50, 60, 70, 80, 90]
        myAvg = excel.WorksheetFunction.Average(mylist)
        print(myAvg)        

gives me back:

        50.0    

Let's make Python, PostgreSQL, and Excle talk to each other:

        import psycopg2, win32com.client as wc, numpy as np 

        conn = psycopg2.connect(dbname= 'tompkins', host = 'localhost', user = 'postgres', password = 'postgres', port = 5432)
        cursor = conn.cursor()
        cursor.execute("""  SELECT asmt
                            FROM tcparcel
                            """)
        result = cursor.fetchall()

        excel = wc.Dispatch('Excel.Application')
        std = excel.WorksheetFunction.StDev(result)

        print(f"The std is {std:.2f}") 
        print ('\n')

        conf = excel.WorksheetFunction.Confidence(0.1, std, len(result))
        avg = np.average(result)

        print (f"Average: {avg:.2f} and confidence interal {conf:.2f} ")
        print ('\n')
        print(f"{(avg - conf):.2f}  {avg:.2f}  {(avg + conf):.2f}")


which returns me back:

        The std is 16457230.44

        Average: 620203.95 and confidence interal 143328.47

        476875.49  620203.95  763532.42


<a name="8"></a>
## Python Geocoding packages 

Geocoding:

Geocoding is the process of converting a human-readable address (such as a street address or postal code) into geographic coordinates (latitude and longitude), which can be used to place the address on a map.

Geocoding is a common technique used in GIS (Geographic Information Systems) and location-based services, such as mapping applications and navigation systems. It enables users to search for and locate addresses, places of interest, and other spatial features on a map, and to perform spatial analysis and visualization.

Geocoding is achieved through the use of geocoding software or geocoding APIs, which take an address as input and return the corresponding geographic coordinates as output. The accuracy of geocoding results can vary depending on the quality and completeness of the input data, the quality of the geocoding software or API, and other factors such as the level of detail of the geographic data used.

<a name="9"></a>
### censusgeocode
**Census Geocode**: Census Geocode is a light weight Python wrapper for the US Census Geocoder API, compatible with Python 3.

        import censusgeocode
        cg = censusgeocode.CensusGeocode()
        census_gc = cg.onelineaddress('20 Bush Lane Ithaca NY')
        print (census_gc[0]['coordinates'])

which returns back

        {'x': -76.48815660622672, 'y': 42.494760511543255}

another example:

        import censusgeocode
        import pandas as pd

        cg = censusgeocode.CensusGeocode()

        path = "D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/"
        # addresses = pd.read_csv(path)
        file_in= open(path + 'addresses.csv', 'r')
        file_out = open(path + 'addresses1.csv', 'w')

        file_out.write('addr, longitude, latitude, accuracy' + '\n')

        for one_add in file_in:
            #print (one_add)
            census_gc = cg.onelineaddress(one_add)
            if len(census_gc)>0:
                print (f"Address: {(one_add)}, x: {(census_gc[0]['coordinates']['x'])}, and y: {census_gc[0]['coordinates']['y']}")
                #file_out.write(str(one_add) + ',' + str(census_gc[0]['coordinates']['x']) + ',' + str(census_gc[0]['coordinates']['y']) + '\n')

        file_out.close()

which returns me back:

        Address: 1446, East Sandy Acres Drive, Salisbury, MD, 21804
        , x: -75.56676982982026, and y: 38.33766113878334
        Address: 5, Hickory Road, Bayville, NY, 11709
        , x: -73.57669116621918, and y: 40.904436098187794
        Address: 20, Bush Lane, Ithaca, NY, 14850
        , x: -76.48815660622672, and y: 42.494760511543255
        Address: 421, South Collingwood Ave, Syracuse, NY, 13210
        , x: -76.10688648579836, and y: 43.061205820321874
        Address: 110, Donna Lea, Buffalo, NY
        , x: -78.77765697722853, and y: 42.98635257394448
        Address: 5, Seneca Court, Port Jefferson Station, NY
        , x: -73.04031499124177, and y: 40.90094460187201
        Address: 5, Highlandview Drive, Bayville, NY, 11709
        , x: -73.57747387789452, and y: 40.905847657228996
        Address: 16, Leslie Lane, Smithtown, NY
        , x: -73.25192026272747, and y: 40.85418157521089
        Address: 1, Noel Court, Smithtown, NY
        , x: -73.21149373865906, and y: 40.8623631734952
        Address: 15, Rosina Drive, Ithaca, NY, 14850
        , x: -76.4858329265534, and y: 42.49574671103065
        Address: 23, Satinwood Drive, Bayville, NY, 11709
        , x: -73.57598778349877, and y: 40.90677892325393
        Address: 244, Sunny Mill Lane, Rochester, NY, 14626
        , x: -77.73156321249466, and y: 43.23376504280916
        Address: 643, E. 6th St., Tucson, AZ, 85705
        , x: -110.96149765720584, and y: 32.22775622733531
        Address: 6803, Ardleigh, St Philadelphia, PA, 19119
        , x: -75.17786413322249, and y: 40.06074826945612
        Address: 119, Atlantic Ave.,  West Sayville, NY, 11796
        , x: -73.09240874964486, and y: 40.72262794407157
        Address: 48, Linda St., Port Jefferson Station, 11776
        , x: -73.06797152216748, and y: 40.92291659813655
        Address: 30, Ridgewood Ave, Lake Hiawatha, NJ, 11111
        , x: -74.39032881461154, and y: 40.885654182699625
        Address: 408, pennsylvania Ave, Salisbury, MD, 21801
        , x: -75.60712817745932, and y: 38.35515285112303
        Address: 9, Preakness Court, Greenlawn, NY, 11740
        , x: -73.3670548831561, and y: 40.85437384783123
        Address: 34, Chichester Ave., Amityville, NY, 11701, x: -73.41792421350073, and y: 40.66098083459507

<a name="10"></a>
### geocoder: 

geocoder library is another example of a geocoding library that works with **multiple mapping providers, including Google, Bing, Yahoo, and OpenStreetMap**. It provides a simple interface for geocoding and reverse geocoding, allowing you to convert addresses into geographic coordinates and **vice versa.**

The cool thing is that I can use Python to talk to PostGIS. Here is a code snippet which first reads addresses from a csv file then geocode these addresses to get their longitude and latitude, then writes them in a table in PostGIS:


        import geocoder
        import psycopg2
        from googleapi import googleapikey
        apikey = googleapikey

        path = "D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/"

        f_in = open(path + 'addresses.csv', 'r')

        conn = psycopg2.connect(dbname= 'tompkins', host = 'localhost', user = 'postgres', password = 'postgres', port = 5432)
        cursor = conn.cursor()

        cursor.execute("DROP TABLE IF EXISTS newpoints")
        cursor.execute("CREATE TABLE newpoints (id SERIAL PRIMARY KEY, address VARCHAR, geom geometry(point, 4326))")

        for one_add in f_in:
            gc = geocoder.google(one_add, key = apikey)
            if gc.accuracy == 'ROOFTOP':
                cursor.execute("INSERT INTO newpoints (address, geom) VALUES ('" + gc.location + "', ST_SetSRID(ST_Point(" + str(gc.lng) + "," + str(gc.lat) + "), 4326))")

        conn.commit()
        cursor.close()
        f_in.close()

Now if I go to QGIS then DB Manager, I can find the newly added table, named newpoints, under the PostGIS -->  tompkins --> Public. I can drag and drop it in the left panel under Layers then I can go to the web --> QuickMapServices --> OSM --> OSM Standard to have the background map on top of my points, which is pretty cool. So now we have a workable GIS database.

<a name="11"></a>
## Python with Desktop ArcGIS and QGIS 

**ArcGIS and ArcPy** -- license required

ArcGIS: 

ArcGIS is not open source. It is a proprietary software suite developed by Esri, a company specializing in geographic information system (GIS) software and solutions. Esri offers various products within the ArcGIS suite, including ArcGIS Desktop, ArcGIS Pro, ArcGIS Online, and ArcGIS Enterprise.


While ArcGIS itself is not open source, Esri does provide APIs and SDKs (Software Development Kits) that allow developers to extend and customize ArcGIS functionality. For example, ArcPy is a Python library provided by Esri that enables scripting and automation within the ArcGIS environment.

**ArcPy:**

ArcPy is a Python library that provides a powerful and comprehensive set of tools for working with and automating tasks in **Esri's ArcGIS software suite**. ArcPy allows you to perform geospatial analysis, manipulate and manage GIS data, create and edit maps, and automate geoprocessing workflows.

Using ArcPy, you can access and manipulate geospatial data in various formats, such as shapefiles, feature classes, raster datasets, and geodatabases. It provides a wide range of geoprocessing functions and tools, enabling you to perform operations like spatial analysis, data conversion, map automation, and more.

ArcPy leverages the functionality of ArcGIS and exposes it through a Python interface. This allows you to write scripts and automate repetitive or complex tasks, making it easier to manage and process geospatial data. You can use ArcPy in standalone Python scripts, in the ArcGIS Python window, or within custom tools and models created using ArcGIS Desktop or ArcGIS Pro.

Some common tasks you can accomplish with ArcPy include:

Geoprocessing: Perform geospatial analysis operations such as buffer, clip, intersect, union, and dissolve.

Data Management: Create, delete, or modify GIS datasets, including feature classes, tables, and raster datasets. You can also manage fields, schema, and attributes of GIS data.

Mapping: Automate the creation and manipulation of maps, including adding layers, changing symbology, and exporting maps to different formats.

Spatial Analysis: Conduct spatial queries, calculate statistics, perform proximity analysis, and generate density maps.

Geocoding and Geolocation: Perform address geocoding, reverse geocoding, and spatial reference transformations.

To use ArcPy, you need to have ArcGIS installed on your machine, as it relies on the ArcGIS Python installation. The specific functionalities available in ArcPy depend on the version of ArcGIS you are using.

**To use ArcPy, you need a valid license for ArcGIS software**. ArcPy is a Python library provided by Esri and is part of the ArcGIS software suite. It allows you to automate tasks and perform geospatial analysis within the ArcGIS environment.

ArcPy relies on the ArcGIS installation and requires a valid license to access and use its functionality. Without a license for ArcGIS, you won't be able to utilize ArcPy or other components of the ArcGIS software suite.

**QGIS and the Python Console within it** -- open source 

https://docs.qgis.org/testing/en/docs/user_manual/processing/console.html

Most of the time, what we do is:

+ Load layers
+ Select layers by attributes
+ Select layers by some spatial operation
+ Perform some kind of spatial analysis

We brifely go over them.

Some handy stuff when working with Python Console in QGIS:

+ To retrieve a specific vector layer named "Floodzones" from the current QGIS project.

        import qgis
        fz = QgsProject.instance().mapLayersByName('Floodzones')[0]

Some notes on the above line: 
+ in order to use the QgsProject class and related functions like mapLayersByName() in the Python Console in QGIS, you need to import the required QGIS modules through import qgis
+ QgsProject.instance() returns the current instance of the QGIS project. The instance() method ensures that we are working with the currently active QGIS project.
+ mapLayersByName('Floodzones') is a method of the QgsProject class that allows you to retrieve map layers based on their names. In this case, it looks for a layer with the name "Floodzones".

So, fz is a variable that references the vector layer named "Floodzones" in the current QGIS project. Once you have assigned the layer to the variable fz, you can perform various operations on this layer, such as querying, editing, or styling. Like:

        fz = QgsProject.instance().mapLayersByName('Floodzones')[0]
        fz.featureCount()

which returns 

        321
        
Or like to select features in the "Floodzones" layer that meet a specific expression or condition, I can do

        fz.selectByExpression("zone = 'AE'")

To deselect the features that were selected using the selectByExpression() method in QGIS Python, you can use the removeSelection() method on the layer object:

        fz.removeSelection()

In this case, the expression filters features based on the value of the attribute field "zone" being equal to 'AE'. selectByExpression() is a method of the QgsVectorLayer class in QGIS that allows you to select features in a vector layer based on an expression. "zone = 'AE'" is the expression used to filter the features. It specifies that only features with the attribute value 'AE' in the field "zone" should be selected. By executing this line of code, the features in the "Floodzones" layer that satisfy the specified expression will be selected. Selected features are visually highlighted in the QGIS interface, typically with a different color or style to distinguish them from the unselected features. **Once the selection is made, you can perform various operations on the selected features, such as extracting attribute information, editing their geometry, or applying specific analysis only to the selected features.** 

Note: The expression used for selection is case-sensitive. In this example, only features with the attribute value 'AE' in the field "zone" will be selected. Adjust the field name and attribute value in the expression to match your actual data.

To get the name of all the zones in the layer:

        import qgis
        fz = QgsProject.instance().mapLayersByName('Floodzones')[0]

        all_zones = []
        for f in fz.getFeatures():
            all_zones.append(f['zone'])

        print(set(all_zones))

which outputs:

        {'A', 'AE', 'X500'}

+ To retrieve a specific vector layer name: 
        
        import qgis

        parcels = QgsProject.instance().mapLayersByName('tompkins — parcels')[0]
        print(parcels.featureCount())

which output:

        35670
        
this retrieves a specific vector layer named "tompkins — parcels" from the current QGIS project. mapLayersByName('tompkins — parcels') is a method of the QgsProject class that allows you to retrieve map layers based on their names. In this case, it looks for a layer with the name "tompkins — parcels". So, parcels is a variable that references the vector layer named "tcparcel" in the current QGIS project. Once you have assigned the layer to the variable parcels, you can perform various operations on this layer, such as querying attributes, analyzing spatial data, or modifying features.

+ To perform buffer analysis:

Now we want to buffer the floodzones:

        import qgis

        testvar = 100

        fz.selectByExpression("zone = 'AE'", QgsVectorLayer.SetSelection)
        mybuff = processing.run("native:buffer", {'INPUT': fz, 'DISTANCE': testvar, 'OUTPUT': 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/fzbuff.shp'})

**processing.run() is a function provided by the QGIS Processing framework that allows you to execute geoprocessing algorithms. It takes two arguments: the algorithm identifier ("native:buffer") and a dictionary of algorithm parameters.**

"native:buffer" is the algorithm identifier for the buffer operation.

{'INPUT': fz, 'DISTANCE': 500, 'OUTPUT': 'path/fzbuff.shp'} is a dictionary of algorithm parameters. It specifies the input layer as fz, the buffer distance as 100 (assuming it is in the same unit as the layer's coordinate system), and the output path for the buffer result as indicated above.

By executing this line of code, the buffer operation will be applied to the selected features in the "fz" layer. The resulting buffer will be stored as a new shapefile at the specified output path, which can be loaded in QGIS through Layer --> Add Layer --> Add Vector Layer.
 
Now that we buffered floodzones, we want to clip parcesl with floodzones: 

        import qgis
        fz = QgsProject.instance().mapLayersByName('tompkins — floodzones')[0]
        fz.selectByExpression('zone = \'AE\'',QgsVectorLayer.SetSelection)
        parcels = QgsProject.instance().mapLayersByName('tompkins — parcels')[0]

        mybuff = processing.run("native:buffer",{'INPUT': fz,'DISTANCE':100, 'OUTPUT':"D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/fzbuff.shp"})
        parclip = processing.run("native:clip",{'INPUT': parcels,'OVERLAY':'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/fzbuff.shp', 'OUTPUT':'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/parclip.shp'}) 
        cliplayer = QgsVectorLayer('c:/temp/parclip.shp','parclip','ogr')
        QgsProject.instance().addMapLayer(cliplayer)

<a name="12"></a>
## Hands-on exercises:

### A. How many facilities are within 0.5 mile of an interstate highway? What are their names? 

In this question facilities refers to toxic release inventories (tri) and interstate highway refers to istates, both of which (i.e., tri and istates) are the layers available in the geodatabases named Fcilities.gdb and Base.gdb, respectively, provided as course materials. 

The python script to solve this problem is as follows:

**First, I need to bring in the data (layers)**:

        import qgis
        tri = iface.addVectorLayer('D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Facilities.gdb|layername=TRI92', "TRI92", "ogr")
        Schools = iface.addVectorLayer('D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Facilities.gdb|layername=Schools', "Schools", "ogr")
        istates = iface.addVectorLayer('D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Base.gdb|layername=istates', "istates", "ogr")

Some explanations:
+  **iface.addVectorLayer** is a function from the QGIS Python API, which is used to add a vector layer to the QGIS interface. The first argument passed to addVectorLayer is the path to the data source, followed by the name of the layer and the driver used to access the data.
+  The **ogr driver** is used to access a wide range of **vector data formats**, such as **shapefiles, GeoJSON, and file geodatabases**. In this case, the data source is specified as 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Base.gdb', which is a file geodatabase. 
+  ogr refers to the OpenGIS Simple Features Reference Implementation, which is a library provided by the GDAL (Geospatial Data Abstraction Library) package. GDAL is a powerful open-source library used for reading, writing, and manipulating geospatial data formats.
+  The |layername=istates parameter specifies that the layer named 'istates' within the geodatabase should be added to the QGIS interface.

**Second we need to craete a buffer around the istates layer**:

        istatebuf = processing.runAndLoadResults("native:buffer",{'INPUT':istates,'DISTANCE':804,'OUTPUT':'memory:'})['OUTPUT']

Some explanations:
+ the processing.runAndLoadResults function from the QGIS Python API is used to execute a geoprocessing algorithm and load the resulting layer into memory. The specific algorithm being executed is "native:buffer," which is used to create a buffer around a vector layer. It takes several parameters that define the input layer, buffer distance, and output.

+ Here is a breakdown of the parameters used in the code:

'INPUT': istates: This parameter specifies the input layer on which the buffer operation will be performed. In this case, the variable istates refers to a vector layer named 'istates', which was previously loaded into QGIS using the iface.addVectorLayer function.

'DISTANCE': 804: This parameter sets the buffer distance. The value of 804 suggests that the buffer will extend 804 units (the unit of measurement depends on the spatial reference system of the input layer) from the geometries of the input layer.

'OUTPUT': 'memory:': This parameter specifies the output location for the buffer result. By setting it to 'memory:', the resulting layer will be loaded into memory, meaning it will be stored in the computer's RAM rather than saved to disk.

**The processing.runAndLoadResults function returns a dictionary, and the buffer result can be accessed using the key 'OUTPUT'. So, ['OUTPUT'] is appended to the function call to obtain the buffer layer.** In summary, the code executes the buffer operation on the istates layer, with a buffer distance of 804 units, and loads the resulting layer into memory, assigning it to the variable istatebuf. This buffer layer can then be used for further analysis or visualization within the QGIS environment.

**Creating a buffer around a layer emans:**

Creating a buffer around a layer means generating a new area or zone that surrounds the existing features of a vector layer. The buffer is typically created by extending the boundaries of the original features by a specified distance.

The buffer operation is commonly used in geospatial analysis and GIS (Geographic Information System) applications for various purposes, including:

+ Proximity Analysis: Buffers can be used to determine areas within a certain distance of specific features. For example, you could create a buffer around a set of points representing schools to identify all the areas within a certain radius where students reside.

+ Spatial Analysis: Buffers can be used to perform spatial operations such as overlay analysis, where you can identify the intersection or proximity between features. For instance, you can create a buffer around rivers and analyze the overlap with land-use zones to identify areas at risk of water pollution.

+ Visualization: Buffers can be visually represented to highlight areas of influence or impact. For example, creating buffers around crime incidents can help identify hotspots or areas with high crime density.

+ Data Preparation: Buffers can be used to preprocess data for subsequent analysis. For example, when conducting network analysis, creating buffers around road networks can help define service areas or catchment zones for facilities like hospitals or retail stores.

The buffer distance determines how far the buffer extends from the original features. It can be specified in various units such as meters, feet, or degrees, depending on the spatial reference system of the data.

By creating a buffer around a layer, you essentially expand the features and create a new area that represents the zone of influence or proximity. This enables you to perform spatial analysis, make informed decisions, and gain insights from the relationships between features and their surroundings.

**on which direction this expansion occurs?**

The expansion of a buffer occurs in all directions, equally around each individual feature of the layer. The buffer operation generates a new polygon or area around each feature, extending it outward in a uniform manner.

The direction of expansion is perpendicular to the boundaries of the original feature. In other words, the buffer creates a zone that is equidistant from the original feature at all points along its boundary.

For example, if you create a buffer around a point feature, the resulting buffer zone will be a circular area extending outward from the point in all directions. Similarly, if you create a buffer around a line feature, the resulting buffer zone will be an area that surrounds the line on both sides, with a width equal to the buffer distance.

In the case of polygon features, the buffer operation expands outward from the outer boundaries of the polygons. The buffer zone will follow the shape of the original polygon, maintaining its overall geometry while extending outward by the specified distance.

It's important to note that the buffer distance is constant in all directions, resulting in a symmetrical expansion. The direction of expansion is perpendicular to the original feature, ensuring that the buffer maintains uniform distance throughout its boundary.

**Third, I need to select the tri features that are inside the buffer**:

        seltri = processing.runAndLoadResults("native:extractbylocation",{'INPUT':tri,'PREDICATE':[0],'INTERSECT':istatebuf,'OUTPUT':'memory:'})['OUTPUT']
 
 Some explanations:
the processing.runAndLoadResults function is used to execute the **"native:extractbylocation"** geoprocessing algorithm in QGIS. This algorithm is used to **extract features from one layer based on their spatial relationship with features from another layer.**

Here is a breakdown of the parameters used in the code:

+ 'INPUT': tri: This parameter specifies the input layer from which features will be extracted. The variable tri represents a vector layer named 'tri'

+ 'PREDICATE': [0]: This parameter specifies the spatial predicate used for the extraction. In this case, **[0] indicates that the predicate used is the "intersects" relationship.** It means that features from the input layer (tri) that intersect with features from the second layer (istatebuf) will be selected. Other options are

        The 'PREDICATE' parameter in the 'native:extractbylocation' algorithm specifies the spatial relationship or predicate used for the extraction. The value [0] represents the "intersects" predicate. However, there are other options available to define different spatial relationships between layers. Here are some commonly used predicates with their corresponding values:

        'within' or [1]: Extracts features from the input layer that are completely within the features of the second layer.
        'contains' or [2]: Extracts features from the input layer that completely contain the features of the second layer.
        'overlap' or [3]: Extracts features from the input layer that have any spatial overlap with the features of the second layer.
        'crosses' or [4]: Extracts features from the input layer that cross the boundaries of the features of the second layer.
        'touches' or [5]: Extracts features from the input layer that touch the boundaries of the features of the second layer.
        'overlaps' or [6]: Extracts features from the input layer that overlap partially or completely with the features of the second layer.
        'equals' or [7]: Extracts features from the input layer that are geometrically identical to the features of the second layer.

For example, if you want to extract features that are completely within the second layer, you can set 'PREDICATE' to [1] or 'within'. Similarly, you can use the other predicates mentioned above to define different spatial relationships between the layers during the extraction process.

+ 'INTERSECT': istatebuf: This parameter specifies the second layer used for the spatial comparison.

+ 'OUTPUT': 'memory:': This parameter indicates the output location for the extracted features. By setting it to 'memory:', the extracted features will be loaded into memory as a new layer.

The processing.runAndLoadResults function returns a dictionary, and the extracted features can be accessed using the key 'OUTPUT'. So, ['OUTPUT'] is appended to the function call to obtain the extracted features layer.

In summary, the code executes the "native:extractbylocation" algorithm to select features from the tri layer that intersect with the istatebuf layer (buffered layer). The resulting extracted features are loaded into memory as a new layer, which is assigned to the variable seltri. This allows for further analysis or visualization of the selected features within the QGIS environment, like:


        myidx = tri.fields().indexFromName('NAME')
        for i in seltri.getFeatures():
            print (i[myidx])
            
but to do the following first I need to run the following to get the actual object back rather than a string:

        seltri = processing.run("native:extractbylocation",{'INPUT':tri,'PREDICATE':[0],'INTERSECT':istatebuf,'OUTPUT':'memory:'})['OUTPUT']

### B. How many Richland County schools could be impacted by an ammonia release from Linday Chemical explosion? (note: ammonia has a general impact area of 5 miles)

First I need to add layers:

        import qgis 
        tri = iface.addVectorLayer('D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Facilities.gdb|layername=TRI92', "TRI92", "ogr")
        Schools = iface.addVectorLayer('D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Facilities.gdb|layername=Schools', "Schools", "ogr")

Then I need to get Lindau Chemical as the toxic release inventory site, to do so I need to extract by expression, as follows. First I'd like to know what unique names are available in my tri layer:

        field_name = 'NAME'  # Name of the 'NAME' field

        # Iterate over features and retrieve unique values in the 'NAME' field
        unique_values = set([feature[field_name] for feature in tri.getFeatures()])

        for value in unique_values:
            print(value)

which outputs:

        COLWOOD CO. INC.
        MICALLINE PRODUCTS INC.
        SQUARE D CO.
        DIAMANT BOART AMERICA
        CARBIDE ALLOYS INC.
        LINDAU CHEMICAL
        KLINE IRON & STEEL CO. INC.
        ANCHOR CONTINENTAL INC.
        CONSOLIDATED SYSTEMS INC.
        OWEN STEEL CO. INC.
        WESTINGHOUSE ELECTRIC CORPORATION
        FN MFG. INC.
        ORCHARD DECORATIVE PRODS.
        AMBAC INTL.
        SUNBIRD BOAT CO. INC.
        SUNOX INC.
        RICHTEX CORP.
        UNION CAMP CORP

then i can extract by expression, as follows:

        lc = processing.runAndLoadResults("native:extractbyexpression", {'INPUT':tri, 'EXPRESSION':'NAME = \'LINDAU CHEMICAL\'','OUTPUT':'memory:'})

the whole script to solve this problem is as follows:

        import qgis

        tri = iface.addVectorLayer('D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Facilities.gdb|layername=TRI92', "TRI92", "ogr")
        Schools = iface.addVectorLayer('D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/RichlandData/Facilities.gdb|layername=Schools', "Schools", "ogr")

        # lc = processing.runAndLoadResults("native:extractbyexpression", {'INPUT':tri, 'EXPRESSION':'NAME = \'LINDAU CHEMICAL\'','OUTPUT':'memory:'})
        lc = processing.run("native:extractbyexpression", {'INPUT':tri, 'EXPRESSION':'NAME = \'LINDAU CHEMICAL\'','OUTPUT':'memory:'})['OUTPUT']

        tribuf = processing.runAndLoadResults("native:buffer",{'INPUT':lc,'DISTANCE':8040,'OUTPUT':'memory:'})['OUTPUT']

        selSchools = processing.run("native:extractbylocation",{'INPUT':Schools,'PREDICATE':[0],'INTERSECT':tribuf,'OUTPUT':'memory:'})['OUTPUT']

        namefield = Schools.fields().indexFromName('NAME')
        for i in selSchools.getFeatures():
            print (i[namefield])
            
which output:

        DREHER
        A C FLORA
        C A JOHNSON
        BRADLEY ELEMENTARY
        BRENNEN ELEMENTARY
        BURTON ELEMENTARY SCHOOL
        CARVER ELEMENTARY
        CRAYTON MIDDLE SCHOOL
        GIBBES HEYWARD MIDDLE
        HAND MIDDLE SCHOOL
        HYATT PARK ELEMENTARY
        LYON STREET ELEMENTARY
        MCCANTS ELEMENTARY
        MEADOWFIELD ELEMENTARY
        A C MOORE ELEMENTARY
        SARAH NANCE
        OLYMPIA SCHOOL
        EDWARD E TAYLOR ELEMENTARY
        ROSEWOOD ELEMENTARY
        SOUTH KILBOURNE ELEMENTARY
        WATKINS ELEMENTARY
        W A PERRY MIDDLE SCHOOL
        HALL INSTITUTE
        BROCKMAN     

### C. Find those census blocks that contain a TRI facility and calculate the total number of people living in a block with a TRI facility, the percentage of the people who live in that block that are white and non-white.


<a name="13"></a>
## Reference
Open Source GIS Stack: Python for Geospatial, Udemy course, instructor: Arthur Lembo


