
## Open Source GIS Stack: Python for Geospatial

Source: **Learning the Open Source GIS Stack: Python for Geospatial** course by Arthur Lembo - udemy cource

We learn about the **FOSS4G** (Free and Open Source Software for Geospatial) stack. The course has 3 parts (excluding the Python review part):
+ Loading software and data
+ Python packages
+  Geospatial additions to Python

### Software installation:

+ **QGIS (Quantum GIS)** is a free and open-source GIS software that allows users to view, edit, and analyze geospatial data. It is designed to provide a user-friendly interface for creating, visualizing, and publishing geospatial information. QGIS can be used for a variety of tasks, such as creating and editing maps, analyzing and manipulating data, and publishing maps and data on the web. QGIS is compatible with a wide range of data formats, including shapefiles, GeoTIFF, KML, and PostGIS. It also supports a range of geospatial operations, such as geocoding, geoprocessing, and spatial analysis. QGIS is a popular choice among researchers, GIS professionals, and other users who need to work with geospatial data. 

link to download: https://www.qgis.org/en/site/forusers/download.html
+ **PostgreSQL**

As  a database management system (DBMS), we use PostgreSQL. 

PostgreSQL and MySQL have many similarities, but they also have some differences in terms of features, performance, and the way they handle certain tasks. For example, PostgreSQL has more advanced features for handling complex data types, concurrency control, and transactions, while MySQL is known for its performance and ease of use.

link to download: https://www.enterprisedb.com/downloads/postgres-postgresql-downloads

**Note on pg_qgs.qgz file (QGIS Project file)**:

The QGIS Project file named "pg_qgs.qgz"which was discussed in the course was missing in the course material. And so I created it through connecting to my PostgreSQL:

To create a QGIS project file that connects to your PostgreSQL database, you can follow these steps:

+ Open QGIS and click on "New Project" to create a new project.

+ In the "Create a new project" window, give your project a name and choose a location to save it.

+ In the "Data Source Manager" window, click on "PostgreSQL" in the left-hand panel to add a new connection to your PostgreSQL database.

+ In the "Create a new PostGIS connection" window, enter the connection details for your PostgreSQL database, including the host, port, database name, and authentication credentials.

+ Once you have entered the connection details, click on "Test Connection" to make sure that the connection is successful. If the connection is successful, click on "OK" to save the connection.

+ In the "Data Source Manager" window, expand the "PostgreSQL" connection to see the list of available tables and views in your database.

+ To add a table or view to your QGIS project, simply drag and drop it from the "Data Source Manager" window into the QGIS canvas.

+ Once you have added all the layers you want to your project, you can save the project by clicking on "Project" in the top menu bar and selecting "Save" or "Save As".

To open the project in QGIS again, simply double-click on the project file (.qgs) or open QGIS and click on "Open Project" in the start menu.


### Useful functions in PostgreSQL's PostGIS extension

+ **ST_TRANSFORM**: is a spatial function in PostgreSQL's PostGIS extension, which is used to transform the spatial reference system (SRS) of a geometry or geography object. 

    SELECT ST_TRANSFORM(geom,4326) AS geom
    FROM firestations

+ **ST_DISTANCE**: is a function in the PostGIS extension for PostgreSQL that calculates the distance between two geometric objects in a specified spatial reference system (SRS).

### SQLITE

Some simple practice:

        import sqlite3
        import os

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        answer = conn.execute('SELECT parcelkey, asmt FROM parcels LIMIT 3')
        for row in answer:
            print (row)

So through the above query I can get the parcel keys and the corresponding assessment values for the first three records:

        ('50070005900000070030000000', 160000.0)
        ('50070005900000070020000000', 260000.0)
        ('50070005700000010020010000', 190000.0)

As another example: 

        import sqlite3
        import os 

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        answer = conn.execute(f"SELECT  propclass, AVG(asmt) AS sumasmt FROM parcels GROUP BY propclass ORDER BY sumasmt ")
        for row in answer: 
            print (f"The average assessment for the property class {row[0]} is $ {row[1]:.2f}")

Which gives me the average assessment for each property class:

        The average assessment for the property class Vacant is $ 68937.44
        The average assessment for the property class   is $ 116666.67
        The average assessment for the property class Forest is $ 125865.74
        The average assessment for the property class Residential is $ 221603.24
        The average assessment for the property class Agriculture is $ 405663.41
        The average assessment for the property class Recreation is $ 922301.08
        The average assessment for the property class Commercial is $ 963517.88
        The average assessment for the property class Public Services is $ 1509577.66
        The average assessment for the property class Industrial is $ 1747535.51
        The average assessment for the property class Community Srvcs is $ 18435283.21

### Spatialite

Spatialite is a spatial extension for SQLite, which is a lightweight, serverless, open-source database management system. Spatialite adds support for spatial data types, spatial indexing, and spatial functions to SQLite, making it a powerful tool for managing and analyzing spatial data. Just like Postgres has PostGSI, SQL Server has SQL Server Spatial, and Oracle has Oracle Spatial, SQLite has Spatialite. 

To activate the Spatial part of SQLite, I need to load extension. So I can execute Spatial functions like ST_Intersects:

        import sqlite3
        import os 

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        conn.enable_load_extension(True) 
        conn.execute('SELECT load_extension("mod_spatialite")')
        answer = conn.execute("""
                        SELECT propclass, SUM(asmt) AS sumasmt
                        FROM parcels, floodzones
                        WHERE ST_INTERSECTS(parcels.geometry, floodzones.geom) AND floodzones.zone ='A'
                        GROUP BY propclass
                        ORDER BY sumasmt
        """)
        for row in answer:
            print (f"Property class {row[0]} has sum of assessment of $ {row[1]}")

which gives me back:

        Property class Industrial has sum of assessment of $ 1379700.0
        Property class Recreation has sum of assessment of $ 1732300.0
        Property class Forest has sum of assessment of $ 10067200.0
        Property class Vacant has sum of assessment of $ 23111320.0
        Property class Commercial has sum of assessment of $ 47901100.0
        Property class Agriculture has sum of assessment of $ 60125100.0
        Property class Public Services has sum of assessment of $ 96326812.0
        Property class Residential has sum of assessment of $ 160711600.0
        Property class Community Srvcs has sum of assessment of $ 6988285900.0

Another example using one of the Spatial functions (ST_DISTANCE) of Spatialite to find the minimum distance of a parcel from the flood zone:

        import sqlite3
        import os 

        os.chdir("C:/Program Files/QGIS 3.30.2/bin")
        path = 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/'
        conn = sqlite3.Connection(path + 'tompkins.sqlite')
        conn.enable_load_extension(True) 
        conn.execute('SELECT load_extension("mod_spatialite")')
        pkey = input('Enter your parcel key: ')
        answer = conn.execute("""   SELECT MIN(ST_DISTANCE(parcels.geometry, floodzones.geom)) AS dist
                                    FROM parcels, floodzones 
                                    WHERE parcels.parcelkey =""" + '\'' + pkey + '\'')
        for row in answer:
            if row [0]== 0:
                print ('parcel intersects the flood zone')
            else:
                print (row[0])

this query return me back (with parcel key of 50308902300000010340000000:

        1626.3723158804592

## Pip installing some usefull packages

        pip install psycopg2 --upgrade
        pip install geocoder --upgrade
        pip install pypiwin32 
        pip install censusgeocode
        pip install geocoder 

Connecting to PostgresSQL and PostGIS using Python:

Before we connected to SQLite through conencting to a file, here we are actually connecting to a database instance, we achive this using psycopg2:

        import psycopg2
        import os 

        conn = psycopg2.connect(dbname= 'tompkins', host = 'localhost', user = 'postgres', password = 'postgres', port = 5432)
        cursor = conn.cursor()
        cursor.execute("""SELECT tcparcel.parcelkey, zone
                            FROM floodzones, tcparcel
                            WHERE ST_INTERSECTS(tcparcel.geom, floodzones.geom)
                            LIMIT 10""")
        result = cursor.fetchall()

        for j in result:
            print (f"Parcel {j[0]} intersects zone {j[1]}")
    
this query gives me back:

        Parcel 50070000200000020040000000 intersects zone AE
        Parcel 50308901800000020100000000 intersects zone AE
        Parcel 50070052500000060010000000 intersects zone AE
        Parcel 50308952500000060010000000 intersects zone AE
        Parcel 50308901800000050150000000 intersects zone AE
        Parcel 50308901800000050020000000 intersects zone AE
        Parcel 50308901800000050140000000 intersects zone AE
        Parcel 50308901800000050050000000 intersects zone AE
        Parcel 50308901800000050090000000 intersects zone AE
        Parcel 50308901800000050120000000 intersects zone AE

## Making Python talk to Microsoft Excel

pypiwin32 is the package that lets us conenct to excel.

We already made python talk to PostgreSQL and through making it talking to Excel, three of them can talk to each other, which would be a great conversation:)!

Through this I can use all the Excel functionalities like:

        import win32com.client as wc

        excel = wc.Dispatch("Excel.Application")
        mylist = [10, 20, 30, 40, 50, 60, 70, 80, 90]
        myAvg = excel.WorksheetFunction.Average(mylist)
        print(myAvg)        

gives me back:

        50.0    

Let's make Python, PostgreSQL, and Excle talk to each other:

        import psycopg2, win32com.client as wc, numpy as np 

        conn = psycopg2.connect(dbname= 'tompkins', host = 'localhost', user = 'postgres', password = 'postgres', port = 5432)
        cursor = conn.cursor()
        cursor.execute("""  SELECT asmt
                            FROM tcparcel
                            """)
        result = cursor.fetchall()

        excel = wc.Dispatch('Excel.Application')
        std = excel.WorksheetFunction.StDev(result)

        print(f"The std is {std:.2f}") 
        print ('\n')

        conf = excel.WorksheetFunction.Confidence(0.1, std, len(result))
        avg = np.average(result)

        print (f"Average: {avg:.2f} and confidence interal {conf:.2f} ")
        print ('\n')
        print(f"{(avg - conf):.2f}  {avg:.2f}  {(avg + conf):.2f}")


which returns me back:

        The std is 16457230.44

        Average: 620203.95 and confidence interal 143328.47

        476875.49  620203.95  763532.42


## Geocoding modules

Geocoding:

Geocoding is the process of converting a human-readable address (such as a street address or postal code) into geographic coordinates (latitude and longitude), which can be used to place the address on a map.

Geocoding is a common technique used in GIS (Geographic Information Systems) and location-based services, such as mapping applications and navigation systems. It enables users to search for and locate addresses, places of interest, and other spatial features on a map, and to perform spatial analysis and visualization.

Geocoding is achieved through the use of geocoding software or geocoding APIs, which take an address as input and return the corresponding geographic coordinates as output. The accuracy of geocoding results can vary depending on the quality and completeness of the input data, the quality of the geocoding software or API, and other factors such as the level of detail of the geographic data used.

**Census Geocode**: Census Geocode is a light weight Python wrapper for the US Census Geocoder API, compatible with Python 3.

        import censusgeocode
        cg = censusgeocode.CensusGeocode()
        census_gc = cg.onelineaddress('20 Bush Lane Ithaca NY')
        print (census_gc[0]['coordinates'])

which returns back

        {'x': -76.48815660622672, 'y': 42.494760511543255}

another example:

        import censusgeocode
        import pandas as pd

        cg = censusgeocode.CensusGeocode()

        path = "D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/"
        # addresses = pd.read_csv(path)
        file_in= open(path + 'addresses.csv', 'r')
        file_out = open(path + 'addresses1.csv', 'w')

        file_out.write('addr, longitude, latitude, accuracy' + '\n')

        for one_add in file_in:
            #print (one_add)
            census_gc = cg.onelineaddress(one_add)
            if len(census_gc)>0:
                print (f"Address: {(one_add)}, x: {(census_gc[0]['coordinates']['x'])}, and y: {census_gc[0]['coordinates']['y']}")
                #file_out.write(str(one_add) + ',' + str(census_gc[0]['coordinates']['x']) + ',' + str(census_gc[0]['coordinates']['y']) + '\n')

        file_out.close()

which returns me back:

        Address: 1446, East Sandy Acres Drive, Salisbury, MD, 21804
        , x: -75.56676982982026, and y: 38.33766113878334
        Address: 5, Hickory Road, Bayville, NY, 11709
        , x: -73.57669116621918, and y: 40.904436098187794
        Address: 20, Bush Lane, Ithaca, NY, 14850
        , x: -76.48815660622672, and y: 42.494760511543255
        Address: 421, South Collingwood Ave, Syracuse, NY, 13210
        , x: -76.10688648579836, and y: 43.061205820321874
        Address: 110, Donna Lea, Buffalo, NY
        , x: -78.77765697722853, and y: 42.98635257394448
        Address: 5, Seneca Court, Port Jefferson Station, NY
        , x: -73.04031499124177, and y: 40.90094460187201
        Address: 5, Highlandview Drive, Bayville, NY, 11709
        , x: -73.57747387789452, and y: 40.905847657228996
        Address: 16, Leslie Lane, Smithtown, NY
        , x: -73.25192026272747, and y: 40.85418157521089
        Address: 1, Noel Court, Smithtown, NY
        , x: -73.21149373865906, and y: 40.8623631734952
        Address: 15, Rosina Drive, Ithaca, NY, 14850
        , x: -76.4858329265534, and y: 42.49574671103065
        Address: 23, Satinwood Drive, Bayville, NY, 11709
        , x: -73.57598778349877, and y: 40.90677892325393
        Address: 244, Sunny Mill Lane, Rochester, NY, 14626
        , x: -77.73156321249466, and y: 43.23376504280916
        Address: 643, E. 6th St., Tucson, AZ, 85705
        , x: -110.96149765720584, and y: 32.22775622733531
        Address: 6803, Ardleigh, St Philadelphia, PA, 19119
        , x: -75.17786413322249, and y: 40.06074826945612
        Address: 119, Atlantic Ave.,  West Sayville, NY, 11796
        , x: -73.09240874964486, and y: 40.72262794407157
        Address: 48, Linda St., Port Jefferson Station, 11776
        , x: -73.06797152216748, and y: 40.92291659813655
        Address: 30, Ridgewood Ave, Lake Hiawatha, NJ, 11111
        , x: -74.39032881461154, and y: 40.885654182699625
        Address: 408, pennsylvania Ave, Salisbury, MD, 21801
        , x: -75.60712817745932, and y: 38.35515285112303
        Address: 9, Preakness Court, Greenlawn, NY, 11740
        , x: -73.3670548831561, and y: 40.85437384783123
        Address: 34, Chichester Ave., Amityville, NY, 11701, x: -73.41792421350073, and y: 40.66098083459507

**geocoder**: 

geocoder library is another example of a geocoding library that works with **multiple mapping providers, including Google, Bing, Yahoo, and OpenStreetMap**. It provides a simple interface for geocoding and reverse geocoding, allowing you to convert addresses into geographic coordinates and **vice versa.**

The cool thing is that I can use Python to talk to PostGIS. Here is a code snippet which first reads addresses from a csv file then geocode these addresses to get their longitude and latitude, then writes them in a table in PostGIS:


        import geocoder
        import psycopg2
        from googleapi import googleapikey
        apikey = googleapikey

        path = "D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/python/"

        f_in = open(path + 'addresses.csv', 'r')

        conn = psycopg2.connect(dbname= 'tompkins', host = 'localhost', user = 'postgres', password = 'postgres', port = 5432)
        cursor = conn.cursor()

        cursor.execute("DROP TABLE IF EXISTS newpoints")
        cursor.execute("CREATE TABLE newpoints (id SERIAL PRIMARY KEY, address VARCHAR, geom geometry(point, 4326))")

        for one_add in f_in:
            gc = geocoder.google(one_add, key = apikey)
            if gc.accuracy == 'ROOFTOP':
                cursor.execute("INSERT INTO newpoints (address, geom) VALUES ('" + gc.location + "', ST_SetSRID(ST_Point(" + str(gc.lng) + "," + str(gc.lat) + "), 4326))")

        conn.commit()
        cursor.close()
        f_in.close()

Now if I go to QGIS then DB Manager, I can find the newly added table, named newpoints, under the PostGIS -->  tompkins --> Public. I can drag and drop it in the left panel under Layers then I can go to the web --> QuickMapServices --> OSM --> OSM Standard to have the background map on top of my points, which is pretty cool. So now we have a workable GIS database.

## Python with Desktop ArcGIS and QGIS 

**ArcGIS and ArcPy** -- license required

ArcGIS: 

ArcGIS is not open source. It is a proprietary software suite developed by Esri, a company specializing in geographic information system (GIS) software and solutions. Esri offers various products within the ArcGIS suite, including ArcGIS Desktop, ArcGIS Pro, ArcGIS Online, and ArcGIS Enterprise.


While ArcGIS itself is not open source, Esri does provide APIs and SDKs (Software Development Kits) that allow developers to extend and customize ArcGIS functionality. For example, ArcPy is a Python library provided by Esri that enables scripting and automation within the ArcGIS environment.

**ArcPy:**

ArcPy is a Python library that provides a powerful and comprehensive set of tools for working with and automating tasks in **Esri's ArcGIS software suite**. ArcPy allows you to perform geospatial analysis, manipulate and manage GIS data, create and edit maps, and automate geoprocessing workflows.

Using ArcPy, you can access and manipulate geospatial data in various formats, such as shapefiles, feature classes, raster datasets, and geodatabases. It provides a wide range of geoprocessing functions and tools, enabling you to perform operations like spatial analysis, data conversion, map automation, and more.

ArcPy leverages the functionality of ArcGIS and exposes it through a Python interface. This allows you to write scripts and automate repetitive or complex tasks, making it easier to manage and process geospatial data. You can use ArcPy in standalone Python scripts, in the ArcGIS Python window, or within custom tools and models created using ArcGIS Desktop or ArcGIS Pro.

Some common tasks you can accomplish with ArcPy include:

Geoprocessing: Perform geospatial analysis operations such as buffer, clip, intersect, union, and dissolve.

Data Management: Create, delete, or modify GIS datasets, including feature classes, tables, and raster datasets. You can also manage fields, schema, and attributes of GIS data.

Mapping: Automate the creation and manipulation of maps, including adding layers, changing symbology, and exporting maps to different formats.

Spatial Analysis: Conduct spatial queries, calculate statistics, perform proximity analysis, and generate density maps.

Geocoding and Geolocation: Perform address geocoding, reverse geocoding, and spatial reference transformations.

To use ArcPy, you need to have ArcGIS installed on your machine, as it relies on the ArcGIS Python installation. The specific functionalities available in ArcPy depend on the version of ArcGIS you are using.

**To use ArcPy, you need a valid license for ArcGIS software**. ArcPy is a Python library provided by Esri and is part of the ArcGIS software suite. It allows you to automate tasks and perform geospatial analysis within the ArcGIS environment.

ArcPy relies on the ArcGIS installation and requires a valid license to access and use its functionality. Without a license for ArcGIS, you won't be able to utilize ArcPy or other components of the ArcGIS software suite.

**QGIS and the Python Console within it** -- open source 

https://docs.qgis.org/testing/en/docs/user_manual/processing/console.html

Most of the time, what we do is:

+ Load layers
+ Select layers by attributes
+ Select layers by some spatial operation
+ Perform some kind of spatial analysis

We brifely go over them.

Some handy stuff when working with Python Console in QGIS:

+ To retrieve a specific vector layer named "Floodzones" from the current QGIS project.

        import qgis
        fz = QgsProject.instance().mapLayersByName('Floodzones')[0]

Some notes on the above line: 
+ in order to use the QgsProject class and related functions like mapLayersByName() in the Python Console in QGIS, you need to import the required QGIS modules through import qgis
+ QgsProject.instance() returns the current instance of the QGIS project. The instance() method ensures that we are working with the currently active QGIS project.
+ mapLayersByName('Floodzones') is a method of the QgsProject class that allows you to retrieve map layers based on their names. In this case, it looks for a layer with the name "Floodzones".

So, fz is a variable that references the vector layer named "Floodzones" in the current QGIS project. Once you have assigned the layer to the variable fz, you can perform various operations on this layer, such as querying, editing, or styling. Like:

        fz = QgsProject.instance().mapLayersByName('Floodzones')[0]
        fz.featureCount()

which returns 

        321
        
Or like to select features in the "Floodzones" layer that meet a specific expression or condition, I can do

        fz.selectByExpression("zone = 'AE'")

To deselect the features that were selected using the selectByExpression() method in QGIS Python, you can use the removeSelection() method on the layer object:

        fz.removeSelection()

In this case, the expression filters features based on the value of the attribute field "zone" being equal to 'AE'. selectByExpression() is a method of the QgsVectorLayer class in QGIS that allows you to select features in a vector layer based on an expression. "zone = 'AE'" is the expression used to filter the features. It specifies that only features with the attribute value 'AE' in the field "zone" should be selected. By executing this line of code, the features in the "Floodzones" layer that satisfy the specified expression will be selected. Selected features are visually highlighted in the QGIS interface, typically with a different color or style to distinguish them from the unselected features. **Once the selection is made, you can perform various operations on the selected features, such as extracting attribute information, editing their geometry, or applying specific analysis only to the selected features.** 

Note: The expression used for selection is case-sensitive. In this example, only features with the attribute value 'AE' in the field "zone" will be selected. Adjust the field name and attribute value in the expression to match your actual data.

To get the name of all the zones in the layer:

        import qgis
        fz = QgsProject.instance().mapLayersByName('Floodzones')[0]

        all_zones = []
        for f in fz.getFeatures():
            all_zones.append(f['zone'])

        print(set(all_zones))

which outputs:

        {'A', 'AE', 'X500'}

+ To retrieve a specific vector layer name: 
        
        import qgis

        parcels = QgsProject.instance().mapLayersByName('tompkins — parcels')[0]
        print(parcels.featureCount())

which output:

        35670
        
this retrieves a specific vector layer named "tompkins — parcels" from the current QGIS project. mapLayersByName('tompkins — parcels') is a method of the QgsProject class that allows you to retrieve map layers based on their names. In this case, it looks for a layer with the name "tompkins — parcels". So, parcels is a variable that references the vector layer named "tcparcel" in the current QGIS project. Once you have assigned the layer to the variable parcels, you can perform various operations on this layer, such as querying attributes, analyzing spatial data, or modifying features.

+ To perform buffer analysis:

Now we want to buffer the floodzones:

        import qgis

        testvar = 100

        fz.selectByExpression("zone = 'AE'", QgsVectorLayer.SetSelection)
        mybuff = processing.run("native:buffer", {'INPUT': fz, 'DISTANCE': testvar, 'OUTPUT': 'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/fzbuff.shp'})

**processing.run() is a function provided by the QGIS Processing framework that allows you to execute geoprocessing algorithms. It takes two arguments: the algorithm identifier ("native:buffer") and a dictionary of algorithm parameters.**

"native:buffer" is the algorithm identifier for the buffer operation.

{'INPUT': fz, 'DISTANCE': 500, 'OUTPUT': 'path/fzbuff.shp'} is a dictionary of algorithm parameters. It specifies the input layer as fz, the buffer distance as 100 (assuming it is in the same unit as the layer's coordinate system), and the output path for the buffer result as indicated above.

By executing this line of code, the buffer operation will be applied to the selected features in the "fz" layer. The resulting buffer will be stored as a new shapefile at the specified output path, which can be loaded in QGIS through Layer --> Add Layer --> Add Vector Layer.
 
Now that we buffered floodzones, we want to clip parcesl with floodzones: 

        import qgis
        fz = QgsProject.instance().mapLayersByName('tompkins — floodzones')[0]
        fz.selectByExpression('zone = \'AE\'',QgsVectorLayer.SetSelection)
        parcels = QgsProject.instance().mapLayersByName('tompkins — parcels')[0]

        mybuff = processing.run("native:buffer",{'INPUT': fz,'DISTANCE':100, 'OUTPUT':"D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/fzbuff.shp"})
        parclip = processing.run("native:clip",{'INPUT': parcels,'OVERLAY':'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/fzbuff.shp', 'OUTPUT':'D:/0_Machine_Learning/Software -- ML Journey/17. Learning the Open Source GIS Stack Python for Gepspatial/parclip.shp'}) 
        cliplayer = QgsVectorLayer('c:/temp/parclip.shp','parclip','ogr')
        QgsProject.instance().addMapLayer(cliplayer)

25. Lab Question 1: How many TRI sites are within .5 miles of the interstate
here
